package org.firstinspires.ftc.teamcode;

import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.Range;

import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;

/**
 * Created by Josh on 11/8/2017.
 */

public class AutonomousCommands {
    Telemetry telemetry;
    LinearOpMode opMode;

    DcMotor rightMotor;
    DcMotor rMotor;
    DcMotor leftMotor;
    DcMotor lMotor;

    Servo intakeBR;
    Servo intakeBL;
    Servo intakeUR;
    Servo intakeUL;
    Servo jewelArm;

    ColorSensor jewelSensorColor;

    BNO055IMU imu;

    boolean initialized = false;

    public AutonomousCommands() {
    }


    public void init(HardwareEEBot robot, LinearOpMode newOpMode) {
        opMode = newOpMode;
        telemetry = newOpMode.telemetry;

        /*rightMotor = hwMap.dcMotor.get("lm");
        rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rightMotor.setPower(0);

        rMotor = hwMap.dcMotor.get("rm");
        rMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rMotor.setDirection(DcMotor.Direction.REVERSE);
        rMotor.setPower(0);

        //sweeper = hwMap.dcMotor.get("sweeper");

        leftMotor = hwMap.dcMotor.get("motor_left2");
        leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        leftMotor.setPower(0);

        lMotor = hwMap.dcMotor.get("motor_right2");
        lMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        lMotor.setDirection(DcMotor.Direction.REVERSE);
        lMotor.setPower(0);

        intakeBR = hwMap.get(Servo.class, "top_conveyor");
        intakeBL = hwMap.get(Servo.class, "bottom_conveyor");
        intakeUR = hwMap.get(Servo.class, "UR_Intake");
        intakeUL = hwMap.get(Servo.class, "UL_Intake");*/
        //jewelArm = robot.jewelArm;

        //jewelSensorColor = robot.jewelSensorColor;

        //imu = robot.imu;

        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();
        parameters.angleUnit            = BNO055IMU.AngleUnit.DEGREES;
        parameters.accelUnit            = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
        parameters.calibrationDataFile  = "BNO055IMUCalibration.json";
        parameters.loggingEnabled       = true;
        parameters.loggingTag           = "IMU";
        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();
        //imu.initialize(parameters);

        initialized = true;
    }

    public void init(HardwareMap hwMap, LinearOpMode newOpMode) {
        opMode = newOpMode;
        telemetry = newOpMode.telemetry;

        rightMotor = hwMap.dcMotor.get("lm");
        rightMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rightMotor.setPower(0);

        rMotor = hwMap.dcMotor.get("rm");
        rMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        rMotor.setDirection(DcMotor.Direction.REVERSE);
        rMotor.setPower(0);

        //sweeper = hwMap.dcMotor.get("sweeper");

        leftMotor = hwMap.dcMotor.get("motor_left2");
        leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        leftMotor.setPower(0);

        lMotor = hwMap.dcMotor.get("motor_right2");
        lMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        lMotor.setDirection(DcMotor.Direction.REVERSE);
        lMotor.setPower(0);

        intakeBR = hwMap.get(Servo.class, "top_conveyor");
        intakeBL = hwMap.get(Servo.class, "bottom_conveyor");
        intakeUR = hwMap.get(Servo.class, "UR_Intake");
        intakeUL = hwMap.get(Servo.class, "UL_Intake");
        jewelArm = hwMap.servo.get("jewelArm");

        jewelSensorColor = hwMap.get(ColorSensor.class, "sensor_color_distance");

        imu = hwMap.get(BNO055IMU.class, "imu");

        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();
        parameters.angleUnit            = BNO055IMU.AngleUnit.DEGREES;
        parameters.accelUnit            = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
        parameters.calibrationDataFile  = "BNO055IMUCalibration.json";
        parameters.loggingEnabled       = true;
        parameters.loggingTag           = "IMU";
        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();
        imu.initialize(parameters);

        initialized = true;
    }

    public void setJewelArmPosition(double pos) {
        jewelArm.setPosition(pos);
    }

    /* Function to turn on/off the intake wheels
    direction is the direction in which the wheels should spin, IN, OUT, or NONE.
    intakePair is the pair of wheels in which to set the direction of.

    REFERENCE; On continuous rotation servos: 0 and 1 are spinning, 0.5 is stop.
     */
    public void changeIntakeDirection(Direction direction, Direction intakePair) {
        if (intakePair == Direction.DOWN) {
            if (direction == Direction.IN) {
                intakeBL.setPosition(1);
                intakeBR.setPosition(0);
            } else if (direction == Direction.OUT) {
                intakeBL.setPosition(0);
                intakeBR.setPosition(1);
            } else {
                intakeBL.setPosition(0.5);
                intakeBR.setPosition(0.5);
            }
        }
        else if (intakePair == Direction.UP) {
            if (direction == Direction.IN) {
                intakeBL.setPosition(0);
                intakeBR.setPosition(1);
            } else if (direction == Direction.OUT) {
                intakeBL.setPosition(1);
                intakeBR.setPosition(0);
            } else {
                intakeBL.setPosition(0.5);
                intakeBR.setPosition(0.5);
            }
        }
    }
    /*
    Drive by gyro function, drives the robot a given length keeping within a certain angle
    targetAngle: The angle we wish to stay on
    speed: The speed of the motors. Unlike last year, -speed means you go backwards.
    distance: The length we wish to travel
    TODO: Convert distance from ticks to inches.
     */
    public boolean gyroDrive(double targetAngle, double speed, int distance, double timeout) {
        if (!initialized) {
            return false;
        }
        // Set the motors to measure encoder counts.
        rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        leftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        lMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        int startRPos = rightMotor.getCurrentPosition();
        int startLPos = leftMotor.getCurrentPosition();
        double startTime = opMode.time;

        // Robot is going backwards when it should be going forwards.
        speed = Range.clip(-speed, -1, 1);
        // Start the loop. Even if we're going backwards, math.abs makes sure that we can still compare to distance.
        while (opMode.opModeIsActive() && (Math.abs(rightMotor.getCurrentPosition() -startRPos) < distance) && (Math.abs(leftMotor.getCurrentPosition() -startLPos) < distance)) {
            if (opMode.time > startTime + timeout) {
                telemetry.addData("Last drive stop:", "Timeout!");
                break;
            }

            Orientation orientation = imu.getAngularOrientation(AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);
            double error = ((orientation.thirdAngle > 180 ? orientation.thirdAngle - 360 : orientation.thirdAngle) - targetAngle) / (25.0);

            telemetry.addData("motorleft dist:", leftMotor.getCurrentPosition() - startLPos);
            telemetry.addData("motorright dist:", rightMotor.getCurrentPosition() - startRPos);
            telemetry.addData("Current z orientation:", orientation.thirdAngle);
            telemetry.addData("error", error);

            double right = speed + error;
            double left = speed - error;

            if (speed < 0) {
                right = Range.clip(right, -1, 1);
                left = Range.clip(left, -1, 1);
            } else {
                right = Range.clip(right, -1, 1);
                left = Range.clip(left, -1, 1);
            }

            rightMotor.setPower(right/5);
            rMotor.setPower(right/5);
            //leftMotor.setPower(left/5);
            //lMotor.setPower(left/5);
            Thread.yield();
        }

        telemetry.addData("Last drive stop:", "Loop complete!");
        rightMotor.setPower(0.0);
        rMotor.setPower(0.0);
        leftMotor.setPower(0.0);
        lMotor.setPower(0.0);

        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        lMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        return (opMode.time < startTime + timeout);
    }

    /*
        The Turn function. Will turn to a given angle
        targetAngle: The angle we wish to turn to.
        speed: The power of the motors
        timeout: Automatic timeout in seconds
        TODO: Convert distance from ticks to inches.
         */
    public boolean gyroTurn(double targetAngle, double speed, double timeout) {
        if (!initialized) {
            return false;
        }
        double startTime = opMode.time;
        double currentAngle = targetAngle + 30;
        double right;
        double left;

        speed = Range.clip(Math.abs(speed), 0, 1);
        // Start the loop. Even if we're going backwards, math.abs makes sure that we can still compare to distance.
        while (Math.abs(targetAngle - currentAngle) > 15) { // Drive until we're within 15 degrees of the starting angle
            if (opMode.time > startTime + timeout) {
                telemetry.addData("Last drive stop:", "Timeout!");
                break;
            }

            Orientation orientation = imu.getAngularOrientation(AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);
            currentAngle = orientation.thirdAngle;

            double slowdown = Math.abs(targetAngle - currentAngle) / 30;
            slowdown = Range.clip(slowdown, 0.1, 1);

            telemetry.addData("Current z orientation:", currentAngle);
            telemetry.addData("Slowdown:", slowdown);

            if (targetAngle - currentAngle > 0) { // This isn't 100% effective
                right = -speed * slowdown;
                left = speed * slowdown;
            }
            else {
                right = speed * slowdown;
                left = -speed * slowdown;
            }

            rightMotor.setPower(right);
            rMotor.setPower(right);
            leftMotor.setPower(left);
            lMotor.setPower(left);
        }

        telemetry.addData("Last drive stop:", "Loop complete!");
        rightMotor.setPower(0.0);
        rMotor.setPower(0.0);
        leftMotor.setPower(0.0);
        lMotor.setPower(0.0);

        rightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        rMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        leftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        lMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        return (opMode.time < startTime + timeout);
    }

    /*
   Function to lower the jewel arm and sense the color
   Returning true means to drive forward (direction of color sensor)
   Returning false means to drive backwards
    */
    public TeamColor jewelRun() {
        jewelArm.setPosition(0.05);
        opMode.sleep(3000);
        telemetry.addData("Red: ", jewelSensorColor.red());
        telemetry.addData("Blue: ", jewelSensorColor.blue());
        telemetry.update();
        if (jewelSensorColor.red() > 5 && jewelSensorColor.red() > jewelSensorColor.blue()) {
            // Direct ball is red
            return TeamColor.RED;
        }
        else if (jewelSensorColor.blue() > 5 && jewelSensorColor.blue() > jewelSensorColor.red()) {
            // Direct ball is blue
            return TeamColor.BLUE;
        }
        else {
            return TeamColor.NONE;
        }
    }
}
